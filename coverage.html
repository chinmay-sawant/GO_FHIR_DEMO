
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-fhir-demo/config/config.go (0.0%)</option>
				
				<option value="file1">go-fhir-demo/docs/docs.go (0.0%)</option>
				
				<option value="file2">go-fhir-demo/internal/api/handlers/external_patient_handler.go (90.5%)</option>
				
				<option value="file3">go-fhir-demo/internal/api/handlers/mocks/mock_external_patient_handler.go (0.0%)</option>
				
				<option value="file4">go-fhir-demo/internal/api/handlers/mocks/mock_patient_handler.go (0.0%)</option>
				
				<option value="file5">go-fhir-demo/internal/api/handlers/patient_handler.go (67.3%)</option>
				
				<option value="file6">go-fhir-demo/internal/api/routes/mocks/mock_routes.go (0.0%)</option>
				
				<option value="file7">go-fhir-demo/internal/api/routes/routes.go (0.0%)</option>
				
				<option value="file8">go-fhir-demo/internal/domain/mocks/mock_external_patient.go (100.0%)</option>
				
				<option value="file9">go-fhir-demo/internal/domain/mocks/mock_patient.go (93.2%)</option>
				
				<option value="file10">go-fhir-demo/internal/domain/patient.go (100.0%)</option>
				
				<option value="file11">go-fhir-demo/internal/middleware/middleware.go (0.0%)</option>
				
				<option value="file12">go-fhir-demo/internal/repository/mocks/mock_patient_repository.go (0.0%)</option>
				
				<option value="file13">go-fhir-demo/internal/repository/patient_repository.go (72.2%)</option>
				
				<option value="file14">go-fhir-demo/internal/service/external_patient_service.go (100.0%)</option>
				
				<option value="file15">go-fhir-demo/internal/service/mocks/mock_external_patient_service.go (0.0%)</option>
				
				<option value="file16">go-fhir-demo/internal/service/mocks/mock_patient_service.go (0.0%)</option>
				
				<option value="file17">go-fhir-demo/internal/service/patient_service.go (72.8%)</option>
				
				<option value="file18">go-fhir-demo/main.go (0.0%)</option>
				
				<option value="file19">go-fhir-demo/pkg/database/database.go (0.0%)</option>
				
				<option value="file20">go-fhir-demo/pkg/fhirclient/client.go (0.0%)</option>
				
				<option value="file21">go-fhir-demo/pkg/fhirclient/mocks/client_mock.go (0.0%)</option>
				
				<option value="file22">go-fhir-demo/pkg/logger/logger.go (20.7%)</option>
				
				<option value="file23">go-fhir-demo/pkg/utils/utils.go (38.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "github.com/joho/godotenv"
        "github.com/spf13/viper"
)

type Config struct {
        Server   ServerConfig   `json:"server"`
        Database DatabaseConfig `json:"database"`
        Logging  LoggingConfig  `json:"logging"`
        FHIR     FHIRConfig     `json:"fhir"`
}

type ServerConfig struct {
        Port                      string        `json:"port"`
        Mode                      string        `json:"mode"`
        ReadTimeout               time.Duration `json:"read_timeout"`
        WriteTimeout              time.Duration `json:"write_timeout"`
        ExternalFHIRServerBaseURL string        `json:"external_fhir_server_base_url"`
}

type DatabaseConfig struct {
        Host            string        `json:"host"`
        Port            string        `json:"port"`
        User            string        `json:"user"`
        Password        string        `json:"password"`
        Name            string        `json:"name"`
        SSLMode         string        `json:"sslmode"`
        MaxIdleConns    int           `json:"max_idle_conns"`
        MaxOpenConns    int           `json:"max_open_conns"`
        ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
}

type LoggingConfig struct {
        Level  string `json:"level"`
        Format string `json:"format"`
        File   string `json:"file"`
}

type FHIRConfig struct {
        BaseURL string `json:"base_url"`
        Version string `json:"version"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file from the root directory if it exists
        _ = godotenv.Load()

        viper.SetConfigName("config")
        viper.SetConfigType("json")
        viper.AddConfigPath("./config")
        viper.AddConfigPath("../config")
        viper.AddConfigPath(".")

        // Set default values
        viper.SetDefault("server.port", "8080")
        viper.SetDefault("server.mode", "debug")
        viper.SetDefault("server.read_timeout", "10s")
        viper.SetDefault("server.write_timeout", "10s")
        viper.SetDefault("database.sslmode", "disable")
        viper.SetDefault("database.max_idle_conns", 10)
        viper.SetDefault("database.max_open_conns", 100)
        viper.SetDefault("database.conn_max_lifetime", "1h")
        viper.SetDefault("logging.level", "info")
        viper.SetDefault("logging.format", "json")
        viper.SetDefault("logging.file", "logs/app.log")
        viper.SetDefault("fhir.base_url", "/api/v1")
        viper.SetDefault("fhir.version", "R4")

        // Bind environment variables
        viper.BindEnv("server.port", "SERVER_PORT")
        viper.BindEnv("server.mode", "GIN_MODE")
        viper.BindEnv("database.host", "DB_HOST")
        viper.BindEnv("database.port", "DB_PORT")
        viper.BindEnv("database.user", "DB_USER")
        viper.BindEnv("database.password", "DB_PASSWORD")
        viper.BindEnv("database.name", "DB_NAME")
        viper.BindEnv("database.sslmode", "DB_SSLMODE")
        viper.BindEnv("logging.level", "LOG_LEVEL")

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading config file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>

        // Override with environment variables for database
        <span class="cov0" title="0">if host := os.Getenv("DB_HOST"); host != "" </span><span class="cov0" title="0">{
                config.Database.Host = host
        }</span>
        <span class="cov0" title="0">if port := os.Getenv("DB_PORT"); port != "" </span><span class="cov0" title="0">{
                config.Database.Port = port
        }</span>
        <span class="cov0" title="0">if user := os.Getenv("DB_USER"); user != "" </span><span class="cov0" title="0">{
                config.Database.User = user
        }</span>
        <span class="cov0" title="0">if password := os.Getenv("DB_PASSWORD"); password != "" </span><span class="cov0" title="0">{
                config.Database.Password = password
        }</span>
        <span class="cov0" title="0">if name := os.Getenv("DB_NAME"); name != "" </span><span class="cov0" title="0">{
                config.Database.Name = name
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (c *DatabaseConfig) DSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.Name, c.SSLMode)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/external-patients": {
            "get": {
                "description": "Searches for patient resources on an external FHIR server based on query parameters",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ExternalPatients"
                ],
                "summary": "Search for external patients",
                "parameters": [
                    {
                        "type": "string",
                        "description": "FHIR search parameters (e.g., name=John,birthdate=1990-01-01)",
                        "name": "_query",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved search results",
                        "schema": {
                            "$ref": "#/definitions/fhir.Bundle"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/external-patients/{id}": {
            "get": {
                "description": "Retrieves a patient resource from an external FHIR server by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ExternalPatients"
                ],
                "summary": "Get an external patient by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Patient ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved patient",
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Patient not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/patients": {
            "get": {
                "description": "Get all FHIR Patient resources with pagination",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Patient"
                ],
                "summary": "Get all Patients",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new FHIR Patient resource",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Patient"
                ],
                "summary": "Create a new Patient",
                "parameters": [
                    {
                        "description": "FHIR Patient resource",
                        "name": "patient",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/patients/{id}": {
            "get": {
                "description": "Get a FHIR Patient resource by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Patient"
                ],
                "summary": "Get a Patient by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Patient ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update an existing FHIR Patient resource",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Patient"
                ],
                "summary": "Update a Patient",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Patient ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "FHIR Patient resource",
                        "name": "patient",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete an existing FHIR Patient resource",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Patient"
                ],
                "summary": "Delete a Patient",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Patient ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "patch": {
                "description": "Partially update an existing FHIR Patient resource",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Patient"
                ],
                "summary": "Partially update a Patient",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Patient ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Partial updates",
                        "name": "patches",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/fhir.Patient"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "fhir.Address": {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "district": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "line": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "period": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "postalCode": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                },
                "text": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/fhir.AddressType"
                },
                "use": {
                    "$ref": "#/definitions/fhir.AddressUse"
                }
            }
        },
        "fhir.AddressType": {
            "type": "integer",
            "enum": [
                0,
                1,
                2
            ],
            "x-enum-varnames": [
                "AddressTypePostal",
                "AddressTypePhysical",
                "AddressTypeBoth"
            ]
        },
        "fhir.AddressUse": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4
            ],
            "x-enum-varnames": [
                "AddressUseHome",
                "AddressUseWork",
                "AddressUseTemp",
                "AddressUseOld",
                "AddressUseBilling"
            ]
        },
        "fhir.AdministrativeGender": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3
            ],
            "x-enum-varnames": [
                "AdministrativeGenderMale",
                "AdministrativeGenderFemale",
                "AdministrativeGenderOther",
                "AdministrativeGenderUnknown"
            ]
        },
        "fhir.Age": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "comparator": {
                    "$ref": "#/definitions/fhir.QuantityComparator"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "system": {
                    "type": "string"
                },
                "unit": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.Annotation": {
            "type": "object",
            "properties": {
                "authorReference": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "authorString": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "text": {
                    "type": "string"
                },
                "time": {
                    "type": "string"
                }
            }
        },
        "fhir.Attachment": {
            "type": "object",
            "properties": {
                "contentType": {
                    "type": "string"
                },
                "creation": {
                    "type": "string"
                },
                "data": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "hash": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "size": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                }
            }
        },
        "fhir.Bundle": {
            "type": "object",
            "properties": {
                "entry": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.BundleEntry"
                    }
                },
                "id": {
                    "type": "string"
                },
                "identifier": {
                    "$ref": "#/definitions/fhir.Identifier"
                },
                "implicitRules": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "link": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.BundleLink"
                    }
                },
                "meta": {
                    "$ref": "#/definitions/fhir.Meta"
                },
                "signature": {
                    "$ref": "#/definitions/fhir.Signature"
                },
                "timestamp": {
                    "type": "string"
                },
                "total": {
                    "type": "integer"
                },
                "type": {
                    "$ref": "#/definitions/fhir.BundleType"
                }
            }
        },
        "fhir.BundleEntry": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "fullUrl": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "link": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.BundleLink"
                    }
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "request": {
                    "$ref": "#/definitions/fhir.BundleEntryRequest"
                },
                "resource": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "response": {
                    "$ref": "#/definitions/fhir.BundleEntryResponse"
                },
                "search": {
                    "$ref": "#/definitions/fhir.BundleEntrySearch"
                }
            }
        },
        "fhir.BundleEntryRequest": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "ifMatch": {
                    "type": "string"
                },
                "ifModifiedSince": {
                    "type": "string"
                },
                "ifNoneExist": {
                    "type": "string"
                },
                "ifNoneMatch": {
                    "type": "string"
                },
                "method": {
                    "$ref": "#/definitions/fhir.HTTPVerb"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "url": {
                    "type": "string"
                }
            }
        },
        "fhir.BundleEntryResponse": {
            "type": "object",
            "properties": {
                "etag": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "lastModified": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "outcome": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "fhir.BundleEntrySearch": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "mode": {
                    "$ref": "#/definitions/fhir.SearchEntryMode"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "score": {
                    "type": "string"
                }
            }
        },
        "fhir.BundleLink": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "relation": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                }
            }
        },
        "fhir.BundleType": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "x-enum-varnames": [
                "BundleTypeDocument",
                "BundleTypeMessage",
                "BundleTypeTransaction",
                "BundleTypeTransactionResponse",
                "BundleTypeBatch",
                "BundleTypeBatchResponse",
                "BundleTypeHistory",
                "BundleTypeSearchset",
                "BundleTypeCollection"
            ]
        },
        "fhir.CodeableConcept": {
            "type": "object",
            "properties": {
                "coding": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Coding"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "text": {
                    "type": "string"
                }
            }
        },
        "fhir.Coding": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "display": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "system": {
                    "type": "string"
                },
                "userSelected": {
                    "type": "boolean"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "fhir.ContactDetail": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "telecom": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.ContactPoint"
                    }
                }
            }
        },
        "fhir.ContactPoint": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "period": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "rank": {
                    "type": "integer"
                },
                "system": {
                    "$ref": "#/definitions/fhir.ContactPointSystem"
                },
                "use": {
                    "$ref": "#/definitions/fhir.ContactPointUse"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.ContactPointSystem": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "x-enum-varnames": [
                "ContactPointSystemPhone",
                "ContactPointSystemFax",
                "ContactPointSystemEmail",
                "ContactPointSystemPager",
                "ContactPointSystemUrl",
                "ContactPointSystemSms",
                "ContactPointSystemOther"
            ]
        },
        "fhir.ContactPointUse": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4
            ],
            "x-enum-varnames": [
                "ContactPointUseHome",
                "ContactPointUseWork",
                "ContactPointUseTemp",
                "ContactPointUseOld",
                "ContactPointUseMobile"
            ]
        },
        "fhir.Contributor": {
            "type": "object",
            "properties": {
                "contact": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.ContactDetail"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/fhir.ContributorType"
                }
            }
        },
        "fhir.ContributorType": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3
            ],
            "x-enum-varnames": [
                "ContributorTypeAuthor",
                "ContributorTypeEditor",
                "ContributorTypeReviewer",
                "ContributorTypeEndorser"
            ]
        },
        "fhir.Count": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "comparator": {
                    "$ref": "#/definitions/fhir.QuantityComparator"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "system": {
                    "type": "string"
                },
                "unit": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.DataRequirement": {
            "type": "object",
            "properties": {
                "codeFilter": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.DataRequirementCodeFilter"
                    }
                },
                "dateFilter": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.DataRequirementDateFilter"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "limit": {
                    "type": "integer"
                },
                "mustSupport": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "profile": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "sort": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.DataRequirementSort"
                    }
                },
                "subjectCodeableConcept": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "subjectReference": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "fhir.DataRequirementCodeFilter": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Coding"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "searchParam": {
                    "type": "string"
                },
                "valueSet": {
                    "type": "string"
                }
            }
        },
        "fhir.DataRequirementDateFilter": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "searchParam": {
                    "type": "string"
                },
                "valueDateTime": {
                    "type": "string"
                },
                "valueDuration": {
                    "$ref": "#/definitions/fhir.Duration"
                },
                "valuePeriod": {
                    "$ref": "#/definitions/fhir.Period"
                }
            }
        },
        "fhir.DataRequirementSort": {
            "type": "object",
            "properties": {
                "direction": {
                    "$ref": "#/definitions/fhir.SortDirection"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                }
            }
        },
        "fhir.DaysOfWeek": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "x-enum-varnames": [
                "DaysOfWeekMon",
                "DaysOfWeekTue",
                "DaysOfWeekWed",
                "DaysOfWeekThu",
                "DaysOfWeekFri",
                "DaysOfWeekSat",
                "DaysOfWeekSun"
            ]
        },
        "fhir.Distance": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "comparator": {
                    "$ref": "#/definitions/fhir.QuantityComparator"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "system": {
                    "type": "string"
                },
                "unit": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.Dosage": {
            "type": "object",
            "properties": {
                "additionalInstruction": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.CodeableConcept"
                    }
                },
                "asNeededBoolean": {
                    "type": "boolean"
                },
                "asNeededCodeableConcept": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "doseAndRate": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.DosageDoseAndRate"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "maxDosePerAdministration": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "maxDosePerLifetime": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "maxDosePerPeriod": {
                    "$ref": "#/definitions/fhir.Ratio"
                },
                "method": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "patientInstruction": {
                    "type": "string"
                },
                "route": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "sequence": {
                    "type": "integer"
                },
                "site": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "text": {
                    "type": "string"
                },
                "timing": {
                    "$ref": "#/definitions/fhir.Timing"
                }
            }
        },
        "fhir.DosageDoseAndRate": {
            "type": "object",
            "properties": {
                "doseQuantity": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "doseRange": {
                    "$ref": "#/definitions/fhir.Range"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "rateQuantity": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "rateRange": {
                    "$ref": "#/definitions/fhir.Range"
                },
                "rateRatio": {
                    "$ref": "#/definitions/fhir.Ratio"
                },
                "type": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                }
            }
        },
        "fhir.Duration": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "comparator": {
                    "$ref": "#/definitions/fhir.QuantityComparator"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "system": {
                    "type": "string"
                },
                "unit": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.Expression": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "expression": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "reference": {
                    "type": "string"
                }
            }
        },
        "fhir.Extension": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                },
                "valueAddress": {
                    "$ref": "#/definitions/fhir.Address"
                },
                "valueAge": {
                    "$ref": "#/definitions/fhir.Age"
                },
                "valueAnnotation": {
                    "$ref": "#/definitions/fhir.Annotation"
                },
                "valueAttachment": {
                    "$ref": "#/definitions/fhir.Attachment"
                },
                "valueBase64Binary": {
                    "type": "string"
                },
                "valueBoolean": {
                    "type": "boolean"
                },
                "valueCanonical": {
                    "type": "string"
                },
                "valueCode": {
                    "type": "string"
                },
                "valueCodeableConcept": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "valueCoding": {
                    "$ref": "#/definitions/fhir.Coding"
                },
                "valueContactDetail": {
                    "$ref": "#/definitions/fhir.ContactDetail"
                },
                "valueContactPoint": {
                    "$ref": "#/definitions/fhir.ContactPoint"
                },
                "valueContributor": {
                    "$ref": "#/definitions/fhir.Contributor"
                },
                "valueCount": {
                    "$ref": "#/definitions/fhir.Count"
                },
                "valueDataRequirement": {
                    "$ref": "#/definitions/fhir.DataRequirement"
                },
                "valueDate": {
                    "type": "string"
                },
                "valueDateTime": {
                    "type": "string"
                },
                "valueDecimal": {
                    "type": "string"
                },
                "valueDistance": {
                    "$ref": "#/definitions/fhir.Distance"
                },
                "valueDosage": {
                    "$ref": "#/definitions/fhir.Dosage"
                },
                "valueDuration": {
                    "$ref": "#/definitions/fhir.Duration"
                },
                "valueExpression": {
                    "$ref": "#/definitions/fhir.Expression"
                },
                "valueHumanName": {
                    "$ref": "#/definitions/fhir.HumanName"
                },
                "valueId": {
                    "type": "string"
                },
                "valueIdentifier": {
                    "$ref": "#/definitions/fhir.Identifier"
                },
                "valueInstant": {
                    "type": "string"
                },
                "valueInteger": {
                    "type": "integer"
                },
                "valueMarkdown": {
                    "type": "string"
                },
                "valueMeta": {
                    "$ref": "#/definitions/fhir.Meta"
                },
                "valueMoney": {
                    "$ref": "#/definitions/fhir.Money"
                },
                "valueOid": {
                    "type": "string"
                },
                "valueParameterDefinition": {
                    "$ref": "#/definitions/fhir.ParameterDefinition"
                },
                "valuePeriod": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "valuePositiveInt": {
                    "type": "integer"
                },
                "valueQuantity": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "valueRange": {
                    "$ref": "#/definitions/fhir.Range"
                },
                "valueRatio": {
                    "$ref": "#/definitions/fhir.Ratio"
                },
                "valueReference": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "valueRelatedArtifact": {
                    "$ref": "#/definitions/fhir.RelatedArtifact"
                },
                "valueSampledData": {
                    "$ref": "#/definitions/fhir.SampledData"
                },
                "valueSignature": {
                    "$ref": "#/definitions/fhir.Signature"
                },
                "valueString": {
                    "type": "string"
                },
                "valueTime": {
                    "type": "string"
                },
                "valueTiming": {
                    "$ref": "#/definitions/fhir.Timing"
                },
                "valueTriggerDefinition": {
                    "$ref": "#/definitions/fhir.TriggerDefinition"
                },
                "valueUnsignedInt": {
                    "type": "integer"
                },
                "valueUri": {
                    "type": "string"
                },
                "valueUrl": {
                    "type": "string"
                },
                "valueUsageContext": {
                    "$ref": "#/definitions/fhir.UsageContext"
                },
                "valueUuid": {
                    "type": "string"
                }
            }
        },
        "fhir.HTTPVerb": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5
            ],
            "x-enum-varnames": [
                "HTTPVerbGET",
                "HTTPVerbHEAD",
                "HTTPVerbPOST",
                "HTTPVerbPUT",
                "HTTPVerbDELETE",
                "HTTPVerbPATCH"
            ]
        },
        "fhir.HumanName": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "family": {
                    "type": "string"
                },
                "given": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "id": {
                    "type": "string"
                },
                "period": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "prefix": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "suffix": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "text": {
                    "type": "string"
                },
                "use": {
                    "$ref": "#/definitions/fhir.NameUse"
                }
            }
        },
        "fhir.Identifier": {
            "type": "object",
            "properties": {
                "assigner": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "period": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "system": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "use": {
                    "$ref": "#/definitions/fhir.IdentifierUse"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.IdentifierUse": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4
            ],
            "x-enum-varnames": [
                "IdentifierUseUsual",
                "IdentifierUseOfficial",
                "IdentifierUseTemp",
                "IdentifierUseSecondary",
                "IdentifierUseOld"
            ]
        },
        "fhir.LinkType": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3
            ],
            "x-enum-varnames": [
                "LinkTypeReplacedBy",
                "LinkTypeReplaces",
                "LinkTypeRefer",
                "LinkTypeSeealso"
            ]
        },
        "fhir.Meta": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "lastUpdated": {
                    "type": "string"
                },
                "profile": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "security": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Coding"
                    }
                },
                "source": {
                    "type": "string"
                },
                "tag": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Coding"
                    }
                },
                "versionId": {
                    "type": "string"
                }
            }
        },
        "fhir.Money": {
            "type": "object",
            "properties": {
                "currency": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.NameUse": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "x-enum-varnames": [
                "NameUseUsual",
                "NameUseOfficial",
                "NameUseTemp",
                "NameUseNickname",
                "NameUseAnonymous",
                "NameUseOld",
                "NameUseMaiden"
            ]
        },
        "fhir.Narrative": {
            "type": "object",
            "properties": {
                "div": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/fhir.NarrativeStatus"
                }
            }
        },
        "fhir.NarrativeStatus": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3
            ],
            "x-enum-varnames": [
                "NarrativeStatusGenerated",
                "NarrativeStatusExtensions",
                "NarrativeStatusAdditional",
                "NarrativeStatusEmpty"
            ]
        },
        "fhir.OperationParameterUse": {
            "type": "integer",
            "enum": [
                0,
                1
            ],
            "x-enum-varnames": [
                "OperationParameterUseIn",
                "OperationParameterUseOut"
            ]
        },
        "fhir.ParameterDefinition": {
            "type": "object",
            "properties": {
                "documentation": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "max": {
                    "type": "string"
                },
                "min": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "profile": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "use": {
                    "$ref": "#/definitions/fhir.OperationParameterUse"
                }
            }
        },
        "fhir.Patient": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "address": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Address"
                    }
                },
                "birthDate": {
                    "type": "string"
                },
                "communication": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.PatientCommunication"
                    }
                },
                "contact": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.PatientContact"
                    }
                },
                "deceasedBoolean": {
                    "type": "boolean"
                },
                "deceasedDateTime": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "gender": {
                    "$ref": "#/definitions/fhir.AdministrativeGender"
                },
                "generalPractitioner": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Reference"
                    }
                },
                "id": {
                    "type": "string"
                },
                "identifier": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Identifier"
                    }
                },
                "implicitRules": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "link": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.PatientLink"
                    }
                },
                "managingOrganization": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "maritalStatus": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "meta": {
                    "$ref": "#/definitions/fhir.Meta"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "multipleBirthBoolean": {
                    "type": "boolean"
                },
                "multipleBirthInteger": {
                    "type": "integer"
                },
                "name": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.HumanName"
                    }
                },
                "photo": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Attachment"
                    }
                },
                "telecom": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.ContactPoint"
                    }
                },
                "text": {
                    "$ref": "#/definitions/fhir.Narrative"
                }
            }
        },
        "fhir.PatientCommunication": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "language": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "preferred": {
                    "type": "boolean"
                }
            }
        },
        "fhir.PatientContact": {
            "type": "object",
            "properties": {
                "address": {
                    "$ref": "#/definitions/fhir.Address"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "gender": {
                    "$ref": "#/definitions/fhir.AdministrativeGender"
                },
                "id": {
                    "type": "string"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "name": {
                    "$ref": "#/definitions/fhir.HumanName"
                },
                "organization": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "period": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "relationship": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.CodeableConcept"
                    }
                },
                "telecom": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.ContactPoint"
                    }
                }
            }
        },
        "fhir.PatientLink": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "other": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "type": {
                    "$ref": "#/definitions/fhir.LinkType"
                }
            }
        },
        "fhir.Period": {
            "type": "object",
            "properties": {
                "end": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "start": {
                    "type": "string"
                }
            }
        },
        "fhir.Quantity": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "comparator": {
                    "$ref": "#/definitions/fhir.QuantityComparator"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "system": {
                    "type": "string"
                },
                "unit": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "fhir.QuantityComparator": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3
            ],
            "x-enum-varnames": [
                "QuantityComparatorLessThan",
                "QuantityComparatorLessOrEquals",
                "QuantityComparatorGreaterOrEquals",
                "QuantityComparatorGreaterThan"
            ]
        },
        "fhir.Range": {
            "type": "object",
            "properties": {
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "high": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "id": {
                    "type": "string"
                },
                "low": {
                    "$ref": "#/definitions/fhir.Quantity"
                }
            }
        },
        "fhir.Ratio": {
            "type": "object",
            "properties": {
                "denominator": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "numerator": {
                    "$ref": "#/definitions/fhir.Quantity"
                }
            }
        },
        "fhir.Reference": {
            "type": "object",
            "properties": {
                "display": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "identifier": {
                    "$ref": "#/definitions/fhir.Identifier"
                },
                "reference": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "fhir.RelatedArtifact": {
            "type": "object",
            "properties": {
                "citation": {
                    "type": "string"
                },
                "display": {
                    "type": "string"
                },
                "document": {
                    "$ref": "#/definitions/fhir.Attachment"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "label": {
                    "type": "string"
                },
                "resource": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/fhir.RelatedArtifactType"
                },
                "url": {
                    "type": "string"
                }
            }
        },
        "fhir.RelatedArtifactType": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "x-enum-varnames": [
                "RelatedArtifactTypeDocumentation",
                "RelatedArtifactTypeJustification",
                "RelatedArtifactTypeCitation",
                "RelatedArtifactTypePredecessor",
                "RelatedArtifactTypeSuccessor",
                "RelatedArtifactTypeDerivedFrom",
                "RelatedArtifactTypeDependsOn",
                "RelatedArtifactTypeComposedOf"
            ]
        },
        "fhir.SampledData": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "string"
                },
                "dimensions": {
                    "type": "integer"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "factor": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "lowerLimit": {
                    "type": "string"
                },
                "origin": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "period": {
                    "type": "string"
                },
                "upperLimit": {
                    "type": "string"
                }
            }
        },
        "fhir.SearchEntryMode": {
            "type": "integer",
            "enum": [
                0,
                1,
                2
            ],
            "x-enum-varnames": [
                "SearchEntryModeMatch",
                "SearchEntryModeInclude",
                "SearchEntryModeOutcome"
            ]
        },
        "fhir.Signature": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "onBehalfOf": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "sigFormat": {
                    "type": "string"
                },
                "targetFormat": {
                    "type": "string"
                },
                "type": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Coding"
                    }
                },
                "when": {
                    "type": "string"
                },
                "who": {
                    "$ref": "#/definitions/fhir.Reference"
                }
            }
        },
        "fhir.SortDirection": {
            "type": "integer",
            "enum": [
                0,
                1
            ],
            "x-enum-varnames": [
                "SortDirectionAscending",
                "SortDirectionDescending"
            ]
        },
        "fhir.Timing": {
            "type": "object",
            "properties": {
                "code": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "event": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "modifierExtension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "repeat": {
                    "$ref": "#/definitions/fhir.TimingRepeat"
                }
            }
        },
        "fhir.TimingRepeat": {
            "type": "object",
            "properties": {
                "boundsDuration": {
                    "$ref": "#/definitions/fhir.Duration"
                },
                "boundsPeriod": {
                    "$ref": "#/definitions/fhir.Period"
                },
                "boundsRange": {
                    "$ref": "#/definitions/fhir.Range"
                },
                "count": {
                    "type": "integer"
                },
                "countMax": {
                    "type": "integer"
                },
                "dayOfWeek": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.DaysOfWeek"
                    }
                },
                "duration": {
                    "type": "string"
                },
                "durationMax": {
                    "type": "string"
                },
                "durationUnit": {
                    "type": "string"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "frequency": {
                    "type": "integer"
                },
                "frequencyMax": {
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "offset": {
                    "type": "integer"
                },
                "period": {
                    "type": "string"
                },
                "periodMax": {
                    "type": "string"
                },
                "periodUnit": {
                    "type": "string"
                },
                "timeOfDay": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "when": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "fhir.TriggerDefinition": {
            "type": "object",
            "properties": {
                "condition": {
                    "$ref": "#/definitions/fhir.Expression"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.DataRequirement"
                    }
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "timingDate": {
                    "type": "string"
                },
                "timingDateTime": {
                    "type": "string"
                },
                "timingReference": {
                    "$ref": "#/definitions/fhir.Reference"
                },
                "timingTiming": {
                    "$ref": "#/definitions/fhir.Timing"
                },
                "type": {
                    "$ref": "#/definitions/fhir.TriggerType"
                }
            }
        },
        "fhir.TriggerType": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "x-enum-varnames": [
                "TriggerTypeNamedEvent",
                "TriggerTypePeriodic",
                "TriggerTypeDataChanged",
                "TriggerTypeDataAdded",
                "TriggerTypeDataModified",
                "TriggerTypeDataRemoved",
                "TriggerTypeDataAccessed",
                "TriggerTypeDataAccessEnded"
            ]
        },
        "fhir.UsageContext": {
            "type": "object",
            "properties": {
                "code": {
                    "$ref": "#/definitions/fhir.Coding"
                },
                "extension": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/fhir.Extension"
                    }
                },
                "id": {
                    "type": "string"
                },
                "valueCodeableConcept": {
                    "$ref": "#/definitions/fhir.CodeableConcept"
                },
                "valueQuantity": {
                    "$ref": "#/definitions/fhir.Quantity"
                },
                "valueRange": {
                    "$ref": "#/definitions/fhir.Range"
                },
                "valueReference": {
                    "$ref": "#/definitions/fhir.Reference"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Go FHIR Demo API",
        Description:      "This is a sample FHIR Patient API server in Go using Gin.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "net/http"

        "go-fhir-demo/internal/domain"
        "go-fhir-demo/pkg/logger"

        "github.com/gin-gonic/gin"
)

// ExternalPatientHandlerInterface defines the contract for external patient handlers
type ExternalPatientHandlerInterface interface {
        GetExternalPatientByID(c *gin.Context)
        SearchExternalPatients(c *gin.Context)
}

// ExternalPatientHandler handles requests for external patient data.
type ExternalPatientHandler struct {
        service domain.ExternalPatientService
}

// NewExternalPatientHandler creates a new ExternalPatientHandler.
func NewExternalPatientHandler(service domain.ExternalPatientService) ExternalPatientHandlerInterface <span class="cov10" title="5">{
        return &amp;ExternalPatientHandler{
                service: service,
        }
}</span>

// GetExternalPatientByID godoc
// @Summary Get an external patient by ID
// @Description Retrieves a patient resource from an external FHIR server by its ID
// @Tags ExternalPatients
// @Produce json
// @Param id path string true "Patient ID"
// @Success 200 {object} fhir.Patient "Successfully retrieved patient"
// @Failure 400 {object} map[string]string "Invalid request"
// @Failure 404 {object} map[string]string "Patient not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /external-patients/{id} [get]
func (h *ExternalPatientHandler) GetExternalPatientByID(c *gin.Context) <span class="cov4" title="2">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Patient ID is required"})
                return
        }</span>

        <span class="cov4" title="2">patient, err := h.service.GetExternalPatientByID(id)
        if err != nil </span><span class="cov1" title="1">{
                // Basic error handling, can be improved to differentiate 404 from 500
                logger.Errorf("Failed to get external patient by ID %s: %v", id, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve patient from external server", "details": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, patient)</span>
}

// SearchExternalPatients godoc
// @Summary Search for external patients
// @Description Searches for patient resources on an external FHIR server based on query parameters
// @Tags ExternalPatients
// @Produce json
// @Param _query query string false "FHIR search parameters (e.g., name=John,birthdate=1990-01-01)"
// @Success 200 {object} fhir.Bundle "Successfully retrieved search results"
// @Failure 400 {object} map[string]string "Invalid request"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /external-patients [get]
func (h *ExternalPatientHandler) SearchExternalPatients(c *gin.Context) <span class="cov4" title="2">{
        queryParams := make(map[string]string)
        for key, values := range c.Request.URL.Query() </span><span class="cov7" title="3">{
                if len(values) &gt; 0 </span><span class="cov7" title="3">{
                        queryParams[key] = values[0] // Taking the first value for simplicity
                }</span>
        }

        <span class="cov4" title="2">bundle, err := h.service.SearchExternalPatients(queryParams)
        if err != nil </span><span class="cov1" title="1">{
                logger.Errorf("Failed to search external patients: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to search patients on external server", "details": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, bundle)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\handlers\external_patient_handler.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\handlers\external_patient_handler.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\handlers\mocks\mock_external_patient_handler.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gin "github.com/gin-gonic/gin"
        gomock "go.uber.org/mock/gomock"
)

// MockExternalPatientHandlerInterface is a mock of ExternalPatientHandlerInterface interface.
type MockExternalPatientHandlerInterface struct {
        ctrl     *gomock.Controller
        recorder *MockExternalPatientHandlerInterfaceMockRecorder
        isgomock struct{}
}

// MockExternalPatientHandlerInterfaceMockRecorder is the mock recorder for MockExternalPatientHandlerInterface.
type MockExternalPatientHandlerInterfaceMockRecorder struct {
        mock *MockExternalPatientHandlerInterface
}

// NewMockExternalPatientHandlerInterface creates a new mock instance.
func NewMockExternalPatientHandlerInterface(ctrl *gomock.Controller) *MockExternalPatientHandlerInterface <span class="cov0" title="0">{
        mock := &amp;MockExternalPatientHandlerInterface{ctrl: ctrl}
        mock.recorder = &amp;MockExternalPatientHandlerInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExternalPatientHandlerInterface) EXPECT() *MockExternalPatientHandlerInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetExternalPatientByID mocks base method.
func (m *MockExternalPatientHandlerInterface) GetExternalPatientByID(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetExternalPatientByID", c)
}</span>

// GetExternalPatientByID indicates an expected call of GetExternalPatientByID.
func (mr *MockExternalPatientHandlerInterfaceMockRecorder) GetExternalPatientByID(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExternalPatientByID", reflect.TypeOf((*MockExternalPatientHandlerInterface)(nil).GetExternalPatientByID), c)
}</span>

// SearchExternalPatients mocks base method.
func (m *MockExternalPatientHandlerInterface) SearchExternalPatients(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SearchExternalPatients", c)
}</span>

// SearchExternalPatients indicates an expected call of SearchExternalPatients.
func (mr *MockExternalPatientHandlerInterfaceMockRecorder) SearchExternalPatients(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchExternalPatients", reflect.TypeOf((*MockExternalPatientHandlerInterface)(nil).SearchExternalPatients), c)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\handlers\patient_handler.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\handlers\patient_handler.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\handlers\mocks\mock_patient_handler.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gin "github.com/gin-gonic/gin"
        gomock "go.uber.org/mock/gomock"
)

// MockPatientHandlerInterface is a mock of PatientHandlerInterface interface.
type MockPatientHandlerInterface struct {
        ctrl     *gomock.Controller
        recorder *MockPatientHandlerInterfaceMockRecorder
        isgomock struct{}
}

// MockPatientHandlerInterfaceMockRecorder is the mock recorder for MockPatientHandlerInterface.
type MockPatientHandlerInterfaceMockRecorder struct {
        mock *MockPatientHandlerInterface
}

// NewMockPatientHandlerInterface creates a new mock instance.
func NewMockPatientHandlerInterface(ctrl *gomock.Controller) *MockPatientHandlerInterface <span class="cov0" title="0">{
        mock := &amp;MockPatientHandlerInterface{ctrl: ctrl}
        mock.recorder = &amp;MockPatientHandlerInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPatientHandlerInterface) EXPECT() *MockPatientHandlerInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreatePatient mocks base method.
func (m *MockPatientHandlerInterface) CreatePatient(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "CreatePatient", c)
}</span>

// CreatePatient indicates an expected call of CreatePatient.
func (mr *MockPatientHandlerInterfaceMockRecorder) CreatePatient(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePatient", reflect.TypeOf((*MockPatientHandlerInterface)(nil).CreatePatient), c)
}</span>

// DeletePatient mocks base method.
func (m *MockPatientHandlerInterface) DeletePatient(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "DeletePatient", c)
}</span>

// DeletePatient indicates an expected call of DeletePatient.
func (mr *MockPatientHandlerInterfaceMockRecorder) DeletePatient(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePatient", reflect.TypeOf((*MockPatientHandlerInterface)(nil).DeletePatient), c)
}</span>

// GetPatient mocks base method.
func (m *MockPatientHandlerInterface) GetPatient(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetPatient", c)
}</span>

// GetPatient indicates an expected call of GetPatient.
func (mr *MockPatientHandlerInterfaceMockRecorder) GetPatient(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatient", reflect.TypeOf((*MockPatientHandlerInterface)(nil).GetPatient), c)
}</span>

// GetPatients mocks base method.
func (m *MockPatientHandlerInterface) GetPatients(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetPatients", c)
}</span>

// GetPatients indicates an expected call of GetPatients.
func (mr *MockPatientHandlerInterfaceMockRecorder) GetPatients(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatients", reflect.TypeOf((*MockPatientHandlerInterface)(nil).GetPatients), c)
}</span>

// PatchPatient mocks base method.
func (m *MockPatientHandlerInterface) PatchPatient(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "PatchPatient", c)
}</span>

// PatchPatient indicates an expected call of PatchPatient.
func (mr *MockPatientHandlerInterfaceMockRecorder) PatchPatient(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchPatient", reflect.TypeOf((*MockPatientHandlerInterface)(nil).PatchPatient), c)
}</span>

// UpdatePatient mocks base method.
func (m *MockPatientHandlerInterface) UpdatePatient(c *gin.Context) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "UpdatePatient", c)
}</span>

// UpdatePatient indicates an expected call of UpdatePatient.
func (mr *MockPatientHandlerInterfaceMockRecorder) UpdatePatient(c any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePatient", reflect.TypeOf((*MockPatientHandlerInterface)(nil).UpdatePatient), c)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "go-fhir-demo/internal/domain"
        "go-fhir-demo/pkg/logger"

        "github.com/gin-gonic/gin"
        "github.com/samply/golang-fhir-models/fhir-models/fhir"
)

// PatientHandlerInterface defines the contract for patient handlers
type PatientHandlerInterface interface {
        CreatePatient(c *gin.Context)
        GetPatient(c *gin.Context)
        GetPatients(c *gin.Context)
        UpdatePatient(c *gin.Context)
        PatchPatient(c *gin.Context)
        DeletePatient(c *gin.Context)
}

// PatientHandler struct
type PatientHandler struct {
        service domain.PatientService
}

// NewPatientHandler creates a new patient handler
func NewPatientHandler(service domain.PatientService) PatientHandlerInterface <span class="cov10" title="12">{
        return &amp;PatientHandler{
                service: service,
        }
}</span>

// CreatePatient handles POST /patients
// @Summary Create a new Patient
// @Description Create a new FHIR Patient resource
// @Tags Patient
// @Accept json
// @Produce json
// @Param patient body fhir.Patient true "FHIR Patient resource"
// @Success 201 {object} fhir.Patient
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /patients [post]
func (h *PatientHandler) CreatePatient(c *gin.Context) <span class="cov4" title="3">{
        var fhirPatient fhir.Patient

        if err := c.ShouldBindJSON(&amp;fhirPatient); err != nil </span><span class="cov1" title="1">{
                logger.Errorf("Failed to bind JSON: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid JSON",
                        "message": err.Error(),
                })
                return
        }</span>

        // Create patient
        <span class="cov3" title="2">patient, err := h.service.CreatePatient(&amp;fhirPatient)
        if err != nil </span><span class="cov1" title="1">{
                logger.Errorf("Failed to create patient: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to create patient",
                        "message": err.Error(),
                })
                return
        }</span>

        // Convert back to FHIR for response
        <span class="cov1" title="1">fhirResponse, err := h.service.ConvertToFHIR(patient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to convert to FHIR: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to convert response",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, fhirResponse)</span>
}

// GetPatient handles GET /patients/:id
// @Summary Get a Patient by ID
// @Description Get a FHIR Patient resource by its ID
// @Tags Patient
// @Produce json
// @Param id path int true "Patient ID"
// @Success 200 {object} fhir.Patient
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /patients/{id} [get]
func (h *PatientHandler) GetPatient(c *gin.Context) <span class="cov4" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid patient ID",
                        "message": "Patient ID must be a valid number",
                })
                return
        }</span>

        <span class="cov3" title="2">patient, err := h.service.GetPatient(uint(id))
        if err != nil </span><span class="cov1" title="1">{
                logger.Errorf("Failed to get patient: %v", err)
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "Patient not found",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">fhirPatient, err := h.service.ConvertToFHIR(patient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to convert to FHIR: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to convert patient data",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, fhirPatient)</span>
}

// GetPatients handles GET /patients
// @Summary Get all Patients
// @Description Get all FHIR Patient resources with pagination
// @Tags Patient
// @Produce json
// @Param limit query int false "Limit" default(10)
// @Param offset query int false "Offset" default(0)
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /patients [get]
func (h *PatientHandler) GetPatients(c *gin.Context) <span class="cov1" title="1">{
        limitStr := c.DefaultQuery("limit", "10")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov1" title="1">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov1" title="1">patients, total, err := h.service.GetPatients(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to get patients: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to get patients",
                        "message": err.Error(),
                })
                return
        }</span>

        // Convert patients to FHIR format
        <span class="cov1" title="1">fhirPatients := make([]*fhir.Patient, 0, len(patients))
        for _, patient := range patients </span><span class="cov3" title="2">{
                fhirPatient, err := h.service.ConvertToFHIR(patient)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to convert patient %d to FHIR: %v", patient.ID, err)
                        continue</span>
                }
                <span class="cov3" title="2">fhirPatients = append(fhirPatients, fhirPatient)</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "patients": fhirPatients,
                "total":    total,
                "limit":    limit,
                "offset":   offset,
        })</span>
}

// UpdatePatient handles PUT /patients/:id
// @Summary Update a Patient
// @Description Update an existing FHIR Patient resource
// @Tags Patient
// @Accept json
// @Produce json
// @Param id path int true "Patient ID"
// @Param patient body fhir.Patient true "FHIR Patient resource"
// @Success 200 {object} fhir.Patient
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /patients/{id} [put]
func (h *PatientHandler) UpdatePatient(c *gin.Context) <span class="cov1" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid patient ID",
                        "message": "Patient ID must be a valid number",
                })
                return
        }</span>

        <span class="cov1" title="1">var fhirPatient fhir.Patient
        if err := c.ShouldBindJSON(&amp;fhirPatient); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to bind JSON: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid JSON",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">patient, err := h.service.UpdatePatient(uint(id), &amp;fhirPatient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to update patient %d: %v", id, err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to update patient",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">fhirResponse, err := h.service.ConvertToFHIR(patient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to convert to FHIR: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to convert response",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, fhirResponse)</span>
}

// PatchPatient handles PATCH /patients/:id
// @Summary Partially update a Patient
// @Description Partially update an existing FHIR Patient resource
// @Tags Patient
// @Accept json
// @Produce json
// @Param id path int true "Patient ID"
// @Param patches body map[string]interface{} true "Partial updates"
// @Success 200 {object} fhir.Patient
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /patients/{id} [patch]
func (h *PatientHandler) PatchPatient(c *gin.Context) <span class="cov1" title="1">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid patient ID",
                        "message": "Patient ID must be a valid number",
                })
                return
        }</span>

        <span class="cov1" title="1">var updates map[string]interface{}
        if err := c.ShouldBindJSON(&amp;updates); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to bind JSON: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid JSON",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">patient, err := h.service.PatchPatient(uint(id), updates)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to patch patient %d: %v", id, err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to patch patient",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">fhirResponse, err := h.service.ConvertToFHIR(patient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to convert to FHIR: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to convert response",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, fhirResponse)</span>
}

// DeletePatient handles DELETE /patients/:id
// @Summary Delete a Patient
// @Description Delete an existing FHIR Patient resource
// @Tags Patient
// @Produce json
// @Param id path int true "Patient ID"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /patients/{id} [delete]
func (h *PatientHandler) DeletePatient(c *gin.Context) <span class="cov4" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid patient ID",
                        "message": "Patient ID must be a valid number",
                })
                return
        }</span>

        <span class="cov3" title="2">err = h.service.DeletePatient(uint(id))
        if err != nil </span><span class="cov1" title="1">{
                logger.Errorf("Failed to delete patient %d: %v", id, err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to delete patient",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\routes\routes.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\routes\routes.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\api\routes\mocks\mock_routes.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        handlers "go-fhir-demo/internal/api/handlers"
        reflect "reflect"

        gin "github.com/gin-gonic/gin"
        gomock "go.uber.org/mock/gomock"
)

// MockRouteSetupInterface is a mock of RouteSetupInterface interface.
type MockRouteSetupInterface struct {
        ctrl     *gomock.Controller
        recorder *MockRouteSetupInterfaceMockRecorder
        isgomock struct{}
}

// MockRouteSetupInterfaceMockRecorder is the mock recorder for MockRouteSetupInterface.
type MockRouteSetupInterfaceMockRecorder struct {
        mock *MockRouteSetupInterface
}

// NewMockRouteSetupInterface creates a new mock instance.
func NewMockRouteSetupInterface(ctrl *gomock.Controller) *MockRouteSetupInterface <span class="cov0" title="0">{
        mock := &amp;MockRouteSetupInterface{ctrl: ctrl}
        mock.recorder = &amp;MockRouteSetupInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRouteSetupInterface) EXPECT() *MockRouteSetupInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SetupRoutes mocks base method.
func (m *MockRouteSetupInterface) SetupRoutes(patientHandler handlers.PatientHandlerInterface, externalPatientHandler handlers.ExternalPatientHandlerInterface) *gin.Engine <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetupRoutes", patientHandler, externalPatientHandler)
        ret0, _ := ret[0].(*gin.Engine)
        return ret0
}</span>

// SetupRoutes indicates an expected call of SetupRoutes.
func (mr *MockRouteSetupInterfaceMockRecorder) SetupRoutes(patientHandler, externalPatientHandler any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetupRoutes", reflect.TypeOf((*MockRouteSetupInterface)(nil).SetupRoutes), patientHandler, externalPatientHandler)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package routes

import (
        "go-fhir-demo/internal/api/handlers"
        "go-fhir-demo/internal/middleware"

        "github.com/gin-gonic/gin"
)

// RouteSetupInterface defines the contract for route setup
type RouteSetupInterface interface {
        SetupRoutes(patientHandler handlers.PatientHandlerInterface, externalPatientHandler handlers.ExternalPatientHandlerInterface) *gin.Engine
}

// RouteSetup implements RouteSetupInterface
type RouteSetup struct{}

// NewRouteSetup creates a new RouteSetup instance
func NewRouteSetup() RouteSetupInterface <span class="cov0" title="0">{
        return &amp;RouteSetup{}
}</span>

// Legacy function for backward compatibility
func SetupRoutes(patientHandler handlers.PatientHandlerInterface, externalPatientHandler handlers.ExternalPatientHandlerInterface) *gin.Engine <span class="cov0" title="0">{
        routeSetup := NewRouteSetup()
        return routeSetup.SetupRoutes(patientHandler, externalPatientHandler)
}</span>

// SetupRoutes configures all the routes for the application
func (r *RouteSetup) SetupRoutes(patientHandler handlers.PatientHandlerInterface, externalPatientHandler handlers.ExternalPatientHandlerInterface) *gin.Engine <span class="cov0" title="0">{
        router := gin.New()

        // Global middleware
        router.Use(middleware.RequestTracker())
        router.Use(middleware.RequestTimer())
        router.Use(middleware.CORS())
        router.Use(middleware.ErrorHandler())
        router.Use(gin.Recovery())

        // Health check endpoint
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":  "healthy",
                        "service": "FHIR Patient API",
                        "version": "1.0.0",
                })
        }</span>)

        // API v1 routes
        <span class="cov0" title="0">v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Patient routes
                patients := v1.Group("/patients")
                </span><span class="cov0" title="0">{
                        patients.GET("", patientHandler.GetPatients)
                        patients.POST("", patientHandler.CreatePatient)
                        patients.GET("/:id", patientHandler.GetPatient)
                        patients.PUT("/:id", patientHandler.UpdatePatient)
                        patients.PATCH("/:id", patientHandler.PatchPatient)
                        patients.DELETE("/:id", patientHandler.DeletePatient)
                }</span>

                // External Patient routes
                <span class="cov0" title="0">externalPatients := v1.Group("/external-patients")
                </span><span class="cov0" title="0">{
                        externalPatients.GET("/:id", externalPatientHandler.GetExternalPatientByID)
                        externalPatients.GET("", externalPatientHandler.SearchExternalPatients)
                }</span>
        }

        // FHIR metadata endpoint
        <span class="cov0" title="0">router.GET("/metadata", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "resourceType": "CapabilityStatement",
                        "status":       "active",
                        "date":         "2025-06-05",
                        "publisher":    "FHIR Demo",
                        "kind":         "instance",
                        "software": gin.H{
                                "name":    "FHIR Patient API",
                                "version": "1.0.0",
                        },
                        "fhirVersion": "4.0.1",
                        "format":      []string{"json"},
                        "rest": []gin.H{
                                {
                                        "mode": "server",
                                        "resource": []gin.H{
                                                {
                                                        "type": "Patient",
                                                        "interaction": []gin.H{
                                                                {"code": "read"},
                                                                {"code": "create"},
                                                                {"code": "update"},
                                                                {"code": "patch"},
                                                                {"code": "delete"},
                                                                {"code": "search-type"},
                                                        },
                                                },
                                        },
                                },
                        },
                })
        }</span>)

        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\domain\external_patient.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\domain\external_patient.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\domain\mocks\mock_external_patient.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        fhir "github.com/samply/golang-fhir-models/fhir-models/fhir"
        gomock "go.uber.org/mock/gomock"
)

// MockExternalPatientService is a mock of ExternalPatientService interface.
type MockExternalPatientService struct {
        ctrl     *gomock.Controller
        recorder *MockExternalPatientServiceMockRecorder
        isgomock struct{}
}

// MockExternalPatientServiceMockRecorder is the mock recorder for MockExternalPatientService.
type MockExternalPatientServiceMockRecorder struct {
        mock *MockExternalPatientService
}

// NewMockExternalPatientService creates a new mock instance.
func NewMockExternalPatientService(ctrl *gomock.Controller) *MockExternalPatientService <span class="cov10" title="5">{
        mock := &amp;MockExternalPatientService{ctrl: ctrl}
        mock.recorder = &amp;MockExternalPatientServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExternalPatientService) EXPECT() *MockExternalPatientServiceMockRecorder <span class="cov8" title="4">{
        return m.recorder
}</span>

// GetExternalPatientByID mocks base method.
func (m *MockExternalPatientService) GetExternalPatientByID(id string) (*fhir.Patient, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetExternalPatientByID", id)
        ret0, _ := ret[0].(*fhir.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetExternalPatientByID indicates an expected call of GetExternalPatientByID.
func (mr *MockExternalPatientServiceMockRecorder) GetExternalPatientByID(id any) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExternalPatientByID", reflect.TypeOf((*MockExternalPatientService)(nil).GetExternalPatientByID), id)
}</span>

// SearchExternalPatients mocks base method.
func (m *MockExternalPatientService) SearchExternalPatients(params map[string]string) (*fhir.Bundle, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchExternalPatients", params)
        ret0, _ := ret[0].(*fhir.Bundle)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchExternalPatients indicates an expected call of SearchExternalPatients.
func (mr *MockExternalPatientServiceMockRecorder) SearchExternalPatients(params any) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchExternalPatients", reflect.TypeOf((*MockExternalPatientService)(nil).SearchExternalPatients), params)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\domain\patient.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\domain\patient.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\domain\mocks\mock_patient.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "go-fhir-demo/internal/domain"
        reflect "reflect"

        fhir "github.com/samply/golang-fhir-models/fhir-models/fhir"
        gomock "go.uber.org/mock/gomock"
)

// MockPatientRepository is a mock of PatientRepository interface.
type MockPatientRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPatientRepositoryMockRecorder
        isgomock struct{}
}

// MockPatientRepositoryMockRecorder is the mock recorder for MockPatientRepository.
type MockPatientRepositoryMockRecorder struct {
        mock *MockPatientRepository
}

// NewMockPatientRepository creates a new mock instance.
func NewMockPatientRepository(ctrl *gomock.Controller) *MockPatientRepository <span class="cov8" title="14">{
        mock := &amp;MockPatientRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPatientRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPatientRepository) EXPECT() *MockPatientRepositoryMockRecorder <span class="cov8" title="14">{
        return m.recorder
}</span>

// Count mocks base method.
func (m *MockPatientRepository) Count() (int64, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Count")
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Count indicates an expected call of Count.
func (mr *MockPatientRepositoryMockRecorder) Count() *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockPatientRepository)(nil).Count))
}</span>

// Create mocks base method.
func (m *MockPatientRepository) Create(patient *domain.Patient) error <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", patient)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPatientRepositoryMockRecorder) Create(patient any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPatientRepository)(nil).Create), patient)
}</span>

// Delete mocks base method.
func (m *MockPatientRepository) Delete(id uint) error <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPatientRepositoryMockRecorder) Delete(id any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPatientRepository)(nil).Delete), id)
}</span>

// GetAll mocks base method.
func (m *MockPatientRepository) GetAll(limit, offset int) ([]*domain.Patient, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", limit, offset)
        ret0, _ := ret[0].([]*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockPatientRepositoryMockRecorder) GetAll(limit, offset any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockPatientRepository)(nil).GetAll), limit, offset)
}</span>

// GetByID mocks base method.
func (m *MockPatientRepository) GetByID(id uint) (*domain.Patient, error) <span class="cov5" title="5">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", id)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockPatientRepositoryMockRecorder) GetByID(id any) *gomock.Call <span class="cov5" title="5">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockPatientRepository)(nil).GetByID), id)
}</span>

// Update mocks base method.
func (m *MockPatientRepository) Update(patient *domain.Patient) error <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", patient)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockPatientRepositoryMockRecorder) Update(patient any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPatientRepository)(nil).Update), patient)
}</span>

// MockPatientService is a mock of PatientService interface.
type MockPatientService struct {
        ctrl     *gomock.Controller
        recorder *MockPatientServiceMockRecorder
        isgomock struct{}
}

// MockPatientServiceMockRecorder is the mock recorder for MockPatientService.
type MockPatientServiceMockRecorder struct {
        mock *MockPatientService
}

// NewMockPatientService creates a new mock instance.
func NewMockPatientService(ctrl *gomock.Controller) *MockPatientService <span class="cov8" title="12">{
        mock := &amp;MockPatientService{ctrl: ctrl}
        mock.recorder = &amp;MockPatientServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPatientService) EXPECT() *MockPatientServiceMockRecorder <span class="cov10" title="21">{
        return m.recorder
}</span>

// ConvertFromFHIR mocks base method.
func (m *MockPatientService) ConvertFromFHIR(fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConvertFromFHIR", fhirPatient)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ConvertFromFHIR indicates an expected call of ConvertFromFHIR.
func (mr *MockPatientServiceMockRecorder) ConvertFromFHIR(fhirPatient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertFromFHIR", reflect.TypeOf((*MockPatientService)(nil).ConvertFromFHIR), fhirPatient)
}</span>

// ConvertToFHIR mocks base method.
func (m *MockPatientService) ConvertToFHIR(patient *domain.Patient) (*fhir.Patient, error) <span class="cov6" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConvertToFHIR", patient)
        ret0, _ := ret[0].(*fhir.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ConvertToFHIR indicates an expected call of ConvertToFHIR.
func (mr *MockPatientServiceMockRecorder) ConvertToFHIR(patient any) *gomock.Call <span class="cov8" title="12">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToFHIR", reflect.TypeOf((*MockPatientService)(nil).ConvertToFHIR), patient)
}</span>

// CreatePatient mocks base method.
func (m *MockPatientService) CreatePatient(fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePatient", fhirPatient)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreatePatient indicates an expected call of CreatePatient.
func (mr *MockPatientServiceMockRecorder) CreatePatient(fhirPatient any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePatient", reflect.TypeOf((*MockPatientService)(nil).CreatePatient), fhirPatient)
}</span>

// DeletePatient mocks base method.
func (m *MockPatientService) DeletePatient(id uint) error <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePatient", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeletePatient indicates an expected call of DeletePatient.
func (mr *MockPatientServiceMockRecorder) DeletePatient(id any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePatient", reflect.TypeOf((*MockPatientService)(nil).DeletePatient), id)
}</span>

// GetPatient mocks base method.
func (m *MockPatientService) GetPatient(id uint) (*domain.Patient, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPatient", id)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPatient indicates an expected call of GetPatient.
func (mr *MockPatientServiceMockRecorder) GetPatient(id any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatient", reflect.TypeOf((*MockPatientService)(nil).GetPatient), id)
}</span>

// GetPatients mocks base method.
func (m *MockPatientService) GetPatients(limit, offset int) ([]*domain.Patient, int64, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPatients", limit, offset)
        ret0, _ := ret[0].([]*domain.Patient)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetPatients indicates an expected call of GetPatients.
func (mr *MockPatientServiceMockRecorder) GetPatients(limit, offset any) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatients", reflect.TypeOf((*MockPatientService)(nil).GetPatients), limit, offset)
}</span>

// PatchPatient mocks base method.
func (m *MockPatientService) PatchPatient(id uint, updates map[string]any) (*domain.Patient, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PatchPatient", id, updates)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// PatchPatient indicates an expected call of PatchPatient.
func (mr *MockPatientServiceMockRecorder) PatchPatient(id, updates any) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchPatient", reflect.TypeOf((*MockPatientService)(nil).PatchPatient), id, updates)
}</span>

// UpdatePatient mocks base method.
func (m *MockPatientService) UpdatePatient(id uint, fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdatePatient", id, fhirPatient)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdatePatient indicates an expected call of UpdatePatient.
func (mr *MockPatientServiceMockRecorder) UpdatePatient(id, fhirPatient any) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePatient", reflect.TypeOf((*MockPatientService)(nil).UpdatePatient), id, fhirPatient)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package domain

import (
        "time"

        "github.com/samply/golang-fhir-models/fhir-models/fhir"
        "gorm.io/gorm"
)

// Patient represents a FHIR Patient resource in the database
type Patient struct {
        ID        uint           `json:"id" gorm:"primaryKey"`
        FHIRData  []byte         `json:"fhir_data" gorm:"type:jsonb;not null"` // Store FHIR JSON as bytes to avoid invalid UTF-8
        Active    *bool          `json:"active" gorm:"index"`
        Family    string         `json:"family" gorm:"index"`
        Given     string         `json:"given" gorm:"index"`
        Gender    string         `json:"gender" gorm:"type:varchar(20);index"`
        BirthDate *time.Time     `json:"birth_date" gorm:"index"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index"`
}

// PatientRepository defines the interface for patient data operations
type PatientRepository interface {
        Create(patient *Patient) error
        GetByID(id uint) (*Patient, error)
        GetAll(limit, offset int) ([]*Patient, error)
        Update(patient *Patient) error
        Delete(id uint) error
        Count() (int64, error)
}

// PatientService defines the interface for patient business logic
type PatientService interface {
        CreatePatient(fhirPatient *fhir.Patient) (*Patient, error)
        GetPatient(id uint) (*Patient, error)
        GetPatients(limit, offset int) ([]*Patient, int64, error)
        UpdatePatient(id uint, fhirPatient *fhir.Patient) (*Patient, error)
        PatchPatient(id uint, updates map[string]interface{}) (*Patient, error)
        DeletePatient(id uint) error
        ConvertToFHIR(patient *Patient) (*fhir.Patient, error)
        ConvertFromFHIR(fhirPatient *fhir.Patient) (*Patient, error)
}

// TableName specifies the table name for Patient model
func (Patient) TableName() string <span class="cov8" title="1">{
        return "patients"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "time"

        "go-fhir-demo/pkg/logger"

        "github.com/gin-gonic/gin"
)

// RequestTracker middleware tracks request and response times
func RequestTracker() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                // Custom log format for request tracking
                logger.Infof("Request: %s %s | Status: %d | Duration: %v | IP: %s | UserAgent: %s",
                        param.Method,
                        param.Path,
                        param.StatusCode,
                        param.Latency,
                        param.ClientIP,
                        param.Request.UserAgent(),
                )
                return ""
        }</span>)
}

// RequestTimer middleware adds request timing information to context
func RequestTimer() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                startTime := time.Now()

                // Set start time in context
                c.Set("request_start_time", startTime)

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(startTime)

                // Set duration in context for potential use in handlers
                c.Set("request_duration", duration)

                // Log request completion
                logger.Debugf("Request completed: %s %s in %v",
                        c.Request.Method,
                        c.Request.URL.Path,
                        duration,
                )
        }</span>
}

// CORS middleware for handling Cross-Origin Resource Sharing
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
                c.Header("Access-Control-Expose-Headers", "Content-Length")
                c.Header("Access-Control-Allow-Credentials", "true")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// ErrorHandler middleware for centralized error handling
func ErrorHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Handle any errors that occurred during request processing
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.Errors.Last()
                        logger.Errorf("Request error: %v", err.Err)

                        // Don't override status if it's already set
                        if c.Writer.Status() == 200 </span><span class="cov0" title="0">{
                                c.JSON(500, gin.H{
                                        "error":   "Internal server error",
                                        "message": err.Error(),
                                })
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\repository\patient_repository.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\repository\patient_repository.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\repository\mocks\mock_patient_repository.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "go-fhir-demo/internal/domain"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockPatientRepositoryInterface is a mock of PatientRepositoryInterface interface.
type MockPatientRepositoryInterface struct {
        ctrl     *gomock.Controller
        recorder *MockPatientRepositoryInterfaceMockRecorder
        isgomock struct{}
}

// MockPatientRepositoryInterfaceMockRecorder is the mock recorder for MockPatientRepositoryInterface.
type MockPatientRepositoryInterfaceMockRecorder struct {
        mock *MockPatientRepositoryInterface
}

// NewMockPatientRepositoryInterface creates a new mock instance.
func NewMockPatientRepositoryInterface(ctrl *gomock.Controller) *MockPatientRepositoryInterface <span class="cov0" title="0">{
        mock := &amp;MockPatientRepositoryInterface{ctrl: ctrl}
        mock.recorder = &amp;MockPatientRepositoryInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPatientRepositoryInterface) EXPECT() *MockPatientRepositoryInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Count mocks base method.
func (m *MockPatientRepositoryInterface) Count() (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Count")
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Count indicates an expected call of Count.
func (mr *MockPatientRepositoryInterfaceMockRecorder) Count() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockPatientRepositoryInterface)(nil).Count))
}</span>

// Create mocks base method.
func (m *MockPatientRepositoryInterface) Create(patient *domain.Patient) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", patient)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPatientRepositoryInterfaceMockRecorder) Create(patient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPatientRepositoryInterface)(nil).Create), patient)
}</span>

// Delete mocks base method.
func (m *MockPatientRepositoryInterface) Delete(id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPatientRepositoryInterfaceMockRecorder) Delete(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPatientRepositoryInterface)(nil).Delete), id)
}</span>

// GetAll mocks base method.
func (m *MockPatientRepositoryInterface) GetAll(limit, offset int) ([]*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", limit, offset)
        ret0, _ := ret[0].([]*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockPatientRepositoryInterfaceMockRecorder) GetAll(limit, offset any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockPatientRepositoryInterface)(nil).GetAll), limit, offset)
}</span>

// GetByID mocks base method.
func (m *MockPatientRepositoryInterface) GetByID(id uint) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", id)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockPatientRepositoryInterfaceMockRecorder) GetByID(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockPatientRepositoryInterface)(nil).GetByID), id)
}</span>

// Update mocks base method.
func (m *MockPatientRepositoryInterface) Update(patient *domain.Patient) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", patient)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockPatientRepositoryInterfaceMockRecorder) Update(patient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPatientRepositoryInterface)(nil).Update), patient)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "go-fhir-demo/internal/domain"
        "go-fhir-demo/pkg/logger"

        "gorm.io/gorm"
)

// PatientRepositoryInterface defines the contract for patient repository
type PatientRepositoryInterface interface {
        Create(patient *domain.Patient) error
        GetByID(id uint) (*domain.Patient, error)
        GetAll(limit, offset int) ([]*domain.Patient, error)
        Update(patient *domain.Patient) error
        Delete(id uint) error
        Count() (int64, error)
}

type patientRepository struct {
        db *gorm.DB
}

// NewPatientRepository creates a new patient repository
func NewPatientRepository(db *gorm.DB) PatientRepositoryInterface <span class="cov1" title="1">{
        return &amp;patientRepository{
                db: db,
        }
}</span>

// Create creates a new patient record
func (r *patientRepository) Create(patient *domain.Patient) error <span class="cov10" title="14">{
        // Ensure FHIRData is valid UTF-8 and does not contain null bytes

        if err := r.db.Create(patient).Error; err != nil </span><span class="cov1" title="1">{
                logger.Errorf("Failed to create patient: %v", err)
                return err
        }</span>
        <span class="cov9" title="13">logger.Infof("Patient created successfully with ID: %d", patient.ID)
        return nil</span>
}

// GetByID retrieves a patient by ID
func (r *patientRepository) GetByID(id uint) (*domain.Patient, error) <span class="cov5" title="4">{
        var patient domain.Patient
        if err := r.db.First(&amp;patient, id).Error; err != nil </span><span class="cov3" title="2">{
                if err == gorm.ErrRecordNotFound </span><span class="cov3" title="2">{
                        logger.Warnf("Patient not found with ID: %d", id)
                        return nil, err
                }</span>
                <span class="cov0" title="0">logger.Errorf("Failed to get patient by ID %d: %v", id, err)
                return nil, err</span>
        }
        <span class="cov3" title="2">return &amp;patient, nil</span>
}

// GetAll retrieves all patients with pagination
func (r *patientRepository) GetAll(limit, offset int) ([]*domain.Patient, error) <span class="cov4" title="3">{
        var patients []*domain.Patient
        query := r.db.Limit(limit).Offset(offset)

        if err := query.Find(&amp;patients).Error; err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to get patients: %v", err)
                return nil, err
        }</span>

        <span class="cov4" title="3">logger.Infof("Retrieved %d patients", len(patients))
        return patients, nil</span>
}

// Update updates an existing patient record
func (r *patientRepository) Update(patient *domain.Patient) error <span class="cov1" title="1">{
        if err := r.db.Save(patient).Error; err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to update patient with ID %d: %v", patient.ID, err)
                return err
        }</span>
        <span class="cov1" title="1">logger.Infof("Patient updated successfully with ID: %d", patient.ID)
        return nil</span>
}

// Delete soft deletes a patient record
func (r *patientRepository) Delete(id uint) error <span class="cov1" title="1">{
        if err := r.db.Delete(&amp;domain.Patient{}, id).Error; err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to delete patient with ID %d: %v", id, err)
                return err
        }</span>
        <span class="cov1" title="1">logger.Infof("Patient deleted successfully with ID: %d", id)
        return nil</span>
}

// Count returns the total number of patients
func (r *patientRepository) Count() (int64, error) <span class="cov3" title="2">{
        var count int64
        if err := r.db.Model(&amp;domain.Patient{}).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to count patients: %v", err)
                return 0, err
        }</span>
        <span class="cov3" title="2">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "go-fhir-demo/pkg/fhirclient"

        "github.com/samply/golang-fhir-models/fhir-models/fhir"
)

// ExternalPatientServiceInterface defines the contract for external patient service
type ExternalPatientServiceInterface interface {
        GetExternalPatientByID(id string) (*fhir.Patient, error)
        SearchExternalPatients(params map[string]string) (*fhir.Bundle, error)
}

type externalPatientService struct {
        client fhirclient.ClientInterface
}

// NewExternalPatientService creates a new ExternalPatientService.
func NewExternalPatientService(client fhirclient.ClientInterface) ExternalPatientServiceInterface <span class="cov10" title="5">{
        return &amp;externalPatientService{
                client: client,
        }
}</span>

// GetExternalPatientByID retrieves a patient from the external FHIR server by ID.
func (s *externalPatientService) GetExternalPatientByID(id string) (*fhir.Patient, error) <span class="cov4" title="2">{
        return s.client.GetPatientByID(id)
}</span>

// SearchExternalPatients searches for patients on the external FHIR server.
func (s *externalPatientService) SearchExternalPatients(params map[string]string) (*fhir.Bundle, error) <span class="cov7" title="3">{
        return s.client.SearchPatients(params)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\service\external_patient_service.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\service\external_patient_service.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\service\mocks\mock_external_patient_service.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        fhir "github.com/samply/golang-fhir-models/fhir-models/fhir"
        gomock "go.uber.org/mock/gomock"
)

// MockExternalPatientServiceInterface is a mock of ExternalPatientServiceInterface interface.
type MockExternalPatientServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockExternalPatientServiceInterfaceMockRecorder
        isgomock struct{}
}

// MockExternalPatientServiceInterfaceMockRecorder is the mock recorder for MockExternalPatientServiceInterface.
type MockExternalPatientServiceInterfaceMockRecorder struct {
        mock *MockExternalPatientServiceInterface
}

// NewMockExternalPatientServiceInterface creates a new mock instance.
func NewMockExternalPatientServiceInterface(ctrl *gomock.Controller) *MockExternalPatientServiceInterface <span class="cov0" title="0">{
        mock := &amp;MockExternalPatientServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockExternalPatientServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExternalPatientServiceInterface) EXPECT() *MockExternalPatientServiceInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetExternalPatientByID mocks base method.
func (m *MockExternalPatientServiceInterface) GetExternalPatientByID(id string) (*fhir.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetExternalPatientByID", id)
        ret0, _ := ret[0].(*fhir.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetExternalPatientByID indicates an expected call of GetExternalPatientByID.
func (mr *MockExternalPatientServiceInterfaceMockRecorder) GetExternalPatientByID(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExternalPatientByID", reflect.TypeOf((*MockExternalPatientServiceInterface)(nil).GetExternalPatientByID), id)
}</span>

// SearchExternalPatients mocks base method.
func (m *MockExternalPatientServiceInterface) SearchExternalPatients(params map[string]string) (*fhir.Bundle, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchExternalPatients", params)
        ret0, _ := ret[0].(*fhir.Bundle)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchExternalPatients indicates an expected call of SearchExternalPatients.
func (mr *MockExternalPatientServiceInterfaceMockRecorder) SearchExternalPatients(params any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchExternalPatients", reflect.TypeOf((*MockExternalPatientServiceInterface)(nil).SearchExternalPatients), params)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\service\patient_service.go
//
// Generated by this command:
//
//        mockgen -source=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\service\patient_service.go -destination=D:\Chinmay_Personal_Projects\Go_FHIR_Demo\internal\service\mocks\mock_patient_service.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "go-fhir-demo/internal/domain"
        reflect "reflect"

        fhir "github.com/samply/golang-fhir-models/fhir-models/fhir"
        gomock "go.uber.org/mock/gomock"
)

// MockPatientServiceInterface is a mock of PatientServiceInterface interface.
type MockPatientServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockPatientServiceInterfaceMockRecorder
        isgomock struct{}
}

// MockPatientServiceInterfaceMockRecorder is the mock recorder for MockPatientServiceInterface.
type MockPatientServiceInterfaceMockRecorder struct {
        mock *MockPatientServiceInterface
}

// NewMockPatientServiceInterface creates a new mock instance.
func NewMockPatientServiceInterface(ctrl *gomock.Controller) *MockPatientServiceInterface <span class="cov0" title="0">{
        mock := &amp;MockPatientServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockPatientServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPatientServiceInterface) EXPECT() *MockPatientServiceInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ConvertFromFHIR mocks base method.
func (m *MockPatientServiceInterface) ConvertFromFHIR(fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConvertFromFHIR", fhirPatient)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ConvertFromFHIR indicates an expected call of ConvertFromFHIR.
func (mr *MockPatientServiceInterfaceMockRecorder) ConvertFromFHIR(fhirPatient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertFromFHIR", reflect.TypeOf((*MockPatientServiceInterface)(nil).ConvertFromFHIR), fhirPatient)
}</span>

// ConvertToFHIR mocks base method.
func (m *MockPatientServiceInterface) ConvertToFHIR(patient *domain.Patient) (*fhir.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConvertToFHIR", patient)
        ret0, _ := ret[0].(*fhir.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ConvertToFHIR indicates an expected call of ConvertToFHIR.
func (mr *MockPatientServiceInterfaceMockRecorder) ConvertToFHIR(patient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToFHIR", reflect.TypeOf((*MockPatientServiceInterface)(nil).ConvertToFHIR), patient)
}</span>

// CreatePatient mocks base method.
func (m *MockPatientServiceInterface) CreatePatient(fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePatient", fhirPatient)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreatePatient indicates an expected call of CreatePatient.
func (mr *MockPatientServiceInterfaceMockRecorder) CreatePatient(fhirPatient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePatient", reflect.TypeOf((*MockPatientServiceInterface)(nil).CreatePatient), fhirPatient)
}</span>

// DeletePatient mocks base method.
func (m *MockPatientServiceInterface) DeletePatient(id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePatient", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeletePatient indicates an expected call of DeletePatient.
func (mr *MockPatientServiceInterfaceMockRecorder) DeletePatient(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePatient", reflect.TypeOf((*MockPatientServiceInterface)(nil).DeletePatient), id)
}</span>

// GetPatient mocks base method.
func (m *MockPatientServiceInterface) GetPatient(id uint) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPatient", id)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPatient indicates an expected call of GetPatient.
func (mr *MockPatientServiceInterfaceMockRecorder) GetPatient(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatient", reflect.TypeOf((*MockPatientServiceInterface)(nil).GetPatient), id)
}</span>

// GetPatients mocks base method.
func (m *MockPatientServiceInterface) GetPatients(limit, offset int) ([]*domain.Patient, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPatients", limit, offset)
        ret0, _ := ret[0].([]*domain.Patient)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetPatients indicates an expected call of GetPatients.
func (mr *MockPatientServiceInterfaceMockRecorder) GetPatients(limit, offset any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatients", reflect.TypeOf((*MockPatientServiceInterface)(nil).GetPatients), limit, offset)
}</span>

// PatchPatient mocks base method.
func (m *MockPatientServiceInterface) PatchPatient(id uint, updates map[string]any) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PatchPatient", id, updates)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// PatchPatient indicates an expected call of PatchPatient.
func (mr *MockPatientServiceInterfaceMockRecorder) PatchPatient(id, updates any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchPatient", reflect.TypeOf((*MockPatientServiceInterface)(nil).PatchPatient), id, updates)
}</span>

// UpdatePatient mocks base method.
func (m *MockPatientServiceInterface) UpdatePatient(id uint, fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdatePatient", id, fhirPatient)
        ret0, _ := ret[0].(*domain.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdatePatient indicates an expected call of UpdatePatient.
func (mr *MockPatientServiceInterfaceMockRecorder) UpdatePatient(id, fhirPatient any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePatient", reflect.TypeOf((*MockPatientServiceInterface)(nil).UpdatePatient), id, fhirPatient)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "encoding/json"
        "fmt"
        "time"

        "go-fhir-demo/internal/domain"
        "go-fhir-demo/pkg/logger"
        "go-fhir-demo/pkg/utils"

        "github.com/samply/golang-fhir-models/fhir-models/fhir"
)

// PatientServiceInterface defines the contract for patient service
type PatientServiceInterface interface {
        CreatePatient(fhirPatient *fhir.Patient) (*domain.Patient, error)
        GetPatient(id uint) (*domain.Patient, error)
        GetPatients(limit, offset int) ([]*domain.Patient, int64, error)
        UpdatePatient(id uint, fhirPatient *fhir.Patient) (*domain.Patient, error)
        PatchPatient(id uint, updates map[string]interface{}) (*domain.Patient, error)
        DeletePatient(id uint) error
        ConvertToFHIR(patient *domain.Patient) (*fhir.Patient, error)
        ConvertFromFHIR(fhirPatient *fhir.Patient) (*domain.Patient, error)
}

type patientService struct {
        repo domain.PatientRepository
}

// NewPatientService creates a new patient service
func NewPatientService(repo domain.PatientRepository) PatientServiceInterface <span class="cov4" title="14">{
        return &amp;patientService{
                repo: repo,
        }
}</span>

// CreatePatient creates a new patient from FHIR data
func (s *patientService) CreatePatient(fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov2" title="2">{
        patient, err := s.ConvertFromFHIR(fhirPatient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to convert FHIR patient: %v", err)
                return nil, err
        }</span>

        <span class="cov2" title="2">if err := s.repo.Create(patient); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return patient, nil</span>
}

// GetPatient retrieves a patient by ID
func (s *patientService) GetPatient(id uint) (*domain.Patient, error) <span class="cov2" title="2">{
        return s.repo.GetByID(id)
}</span>

// GetPatients retrieves all patients with pagination
func (s *patientService) GetPatients(limit, offset int) ([]*domain.Patient, int64, error) <span class="cov2" title="2">{
        patients, err := s.repo.GetAll(limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">count, err := s.repo.Count()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">return patients, count, nil</span>
}

// UpdatePatient updates an existing patient
func (s *patientService) UpdatePatient(id uint, fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov2" title="2">{
        existingPatient, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Convert FHIR data to domain model
        <span class="cov1" title="1">updatedPatient, err := s.ConvertFromFHIR(fhirPatient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Preserve ID and timestamps
        <span class="cov1" title="1">updatedPatient.ID = existingPatient.ID
        updatedPatient.CreatedAt = existingPatient.CreatedAt

        if err := s.repo.Update(updatedPatient); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return updatedPatient, nil</span>
}

// PatchPatient partially updates a patient
func (s *patientService) PatchPatient(id uint, updates map[string]interface{}) (*domain.Patient, error) <span class="cov1" title="1">{
        patient, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse existing FHIR data
        <span class="cov1" title="1">fhirPatient, err := s.ConvertToFHIR(patient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse existing FHIR data: %w", err)
        }</span>

        // Apply updates to FHIR patient
        <span class="cov1" title="1">if err := s.applyUpdatesToFHIR(fhirPatient, updates); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert back to domain model
        <span class="cov1" title="1">updatedPatient, err := s.ConvertFromFHIR(fhirPatient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Preserve ID and timestamps
        <span class="cov1" title="1">updatedPatient.ID = patient.ID
        updatedPatient.CreatedAt = patient.CreatedAt

        if err := s.repo.Update(updatedPatient); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return updatedPatient, nil</span>
}

// DeletePatient deletes a patient
func (s *patientService) DeletePatient(id uint) error <span class="cov2" title="2">{
        return s.repo.Delete(id)
}</span>

// ConvertToFHIR converts a domain patient to FHIR format
func (s *patientService) ConvertToFHIR(patient *domain.Patient) (*fhir.Patient, error) <span class="cov2" title="3">{
        var fhirPatient fhir.Patient
        if err := json.Unmarshal([]byte(patient.FHIRData), &amp;fhirPatient); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to unmarshal FHIR data: %w", err)
        }</span>
        <span class="cov2" title="2">return &amp;fhirPatient, nil</span>
}

// ConvertFromFHIR converts a FHIR patient to domain format
func (s *patientService) ConvertFromFHIR(fhirPatient *fhir.Patient) (*domain.Patient, error) <span class="cov3" title="5">{
        // Marshal FHIR patient to JSON
        fhirJSON, err := json.Marshal(fhirPatient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal FHIR patient: %w", err)
        }</span>

        // Remove any invalid UTF-8 byte 0x00 from the JSON
        <span class="cov3" title="5">cleaned := make([]byte, 0, len(fhirJSON))
        for _, b := range fhirJSON </span><span class="cov10" title="506">{
                if b != 0x00 </span><span class="cov10" title="506">{
                        cleaned = append(cleaned, b)
                }</span>
        }

        <span class="cov3" title="5">patient := &amp;domain.Patient{
                FHIRData: cleaned,
        }

        // Extract searchable fields
        if fhirPatient.Active != nil </span><span class="cov3" title="5">{
                patient.Active = fhirPatient.Active
        }</span>

        // Extract name information
        <span class="cov3" title="5">if len(fhirPatient.Name) &gt; 0 </span><span class="cov3" title="5">{
                name := fhirPatient.Name[0]
                if name.Family != nil </span><span class="cov3" title="5">{
                        patient.Family = *name.Family
                }</span>
                <span class="cov3" title="5">if len(name.Given) &gt; 0 </span><span class="cov3" title="5">{
                        patient.Given = name.Given[0]
                }</span>
        }

        // Extract gender
        <span class="cov3" title="5">if fhirPatient.Gender != nil </span><span class="cov2" title="2">{
                patient.Gender = fhirPatient.Gender.String()
        }</span>

        // Extract birth date
        <span class="cov3" title="5">if fhirPatient.BirthDate != nil </span><span class="cov2" title="2">{
                if birthDate, err := time.Parse("2006-01-02", *fhirPatient.BirthDate); err == nil </span><span class="cov2" title="2">{
                        patient.BirthDate = &amp;birthDate
                }</span>
        }

        <span class="cov3" title="5">return patient, nil</span>
}

// applyUpdatesToFHIR applies partial updates to a FHIR patient
func (s *patientService) applyUpdatesToFHIR(fhirPatient *fhir.Patient, updates map[string]interface{}) error <span class="cov1" title="1">{
        for key, value := range updates </span><span class="cov2" title="2">{
                switch key </span>{
                case "active":<span class="cov1" title="1">
                        if active, ok := value.(bool); ok </span><span class="cov1" title="1">{
                                fhirPatient.Active = &amp;active
                        }</span>
                case "family":<span class="cov1" title="1">
                        if family, ok := value.(string); ok </span><span class="cov1" title="1">{
                                if len(fhirPatient.Name) == 0 </span><span class="cov0" title="0">{
                                        fhirPatient.Name = []fhir.HumanName{{}}
                                }</span>
                                <span class="cov1" title="1">fhirPatient.Name[0].Family = &amp;family</span>
                        }
                case "given":<span class="cov0" title="0">
                        if given, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if len(fhirPatient.Name) == 0 </span><span class="cov0" title="0">{
                                        fhirPatient.Name = []fhir.HumanName{{}}
                                }</span>
                                <span class="cov0" title="0">if fhirPatient.Name[0].Given == nil </span><span class="cov0" title="0">{
                                        fhirPatient.Name[0].Given = []string{given}
                                }</span> else<span class="cov0" title="0"> {
                                        fhirPatient.Name[0].Given = []string{given}
                                }</span>
                        }
                case "gender":<span class="cov0" title="0">
                        if gender, ok := value.(string); ok </span><span class="cov0" title="0">{
                                // Validate gender values according to FHIR spec
                                if gender == "male" || gender == "female" || gender == "other" || gender == "unknown" </span><span class="cov0" title="0">{
                                        gender := fhir.AdministrativeGender(*utils.GenderPtr(gender))
                                        fhirPatient.Gender = &amp;gender
                                }</span>
                        }
                case "birthDate":<span class="cov0" title="0">
                        if birthDate, ok := value.(string); ok </span><span class="cov0" title="0">{
                                // Validate date format
                                if _, err := time.Parse("2006-01-02", birthDate); err == nil </span><span class="cov0" title="0">{
                                        fhirPatient.BirthDate = &amp;birthDate
                                }</span>
                        }
                }
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "go-fhir-demo/config"
        "go-fhir-demo/internal/api/handlers"
        "go-fhir-demo/internal/api/routes"
        "go-fhir-demo/internal/domain"
        "go-fhir-demo/internal/repository"
        "go-fhir-demo/internal/service"
        "go-fhir-demo/pkg/database"
        "go-fhir-demo/pkg/fhirclient" // Import the new fhirclient package
        "go-fhir-demo/pkg/logger"
        "go-fhir-demo/pkg/utils"

        "github.com/gin-gonic/gin"
        "github.com/samply/golang-fhir-models/fhir-models/fhir"

        // Swagger imports
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"

        // docs is generated by Swag CLI, you have to import it.
        _ "go-fhir-demo/docs"
)

// @title Go FHIR Demo API
// @version 1.0
// @description This is a sample FHIR Patient API server in Go using Gin.
// @BasePath /api/v1

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load configuration: %v\n", err)
                os.Exit(1)
        }</span>

        // Initialize logger
        <span class="cov0" title="0">if err := logger.Initialize(cfg.Logging.Level, cfg.Logging.Format, cfg.Logging.File); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Starting FHIR Patient API server...")

        // Initialize database
        if err := database.Initialize(&amp;cfg.Database); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to initialize database: %v", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // Auto-migrate the database schema
        db := database.GetDB()
        if err := db.AutoMigrate(&amp;domain.Patient{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to migrate database: %v", err)
                os.Exit(1)
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">patientRepo := repository.NewPatientRepository(db)

        // Initialize services
        patientService := service.NewPatientService(patientRepo)

        // Initialize FHIR client
        fhirClient := fhirclient.NewClient(cfg.Server.ExternalFHIRServerBaseURL)

        // Initialize external patient service
        externalPatientService := service.NewExternalPatientService(fhirClient)

        // --- Seed dummy patients if not present ---
        dummyPatients := []fhir.Patient{
                {
                        Active: utils.CreateBoolPtr(true),
                        Name: []fhir.HumanName{
                                {
                                        Use:    utils.NameUseOfficialPtr(),
                                        Family: utils.CreateStringPtr("Doe"),
                                        Given:  []string{"John"},
                                },
                        },
                        Gender:    utils.GenderPtr("male"),
                        BirthDate: utils.CreateStringPtr("1980-01-01"),
                        Telecom: []fhir.ContactPoint{
                                {
                                        System: utils.SystemPtr("phone"),
                                        Value:  utils.CreateStringPtr("1234567890"),
                                        Use:    utils.UsePtr("mobile"),
                                },
                        },
                        Address: []fhir.Address{
                                {
                                        Line:       []string{"123 Main St"},
                                        City:       utils.CreateStringPtr("Metropolis"),
                                        State:      utils.CreateStringPtr("NY"),
                                        PostalCode: utils.CreateStringPtr("12345"),
                                        Country:    utils.CreateStringPtr("USA"),
                                },
                        },
                },
                {
                        Active: utils.CreateBoolPtr(true),
                        Name: []fhir.HumanName{
                                {
                                        Use:    utils.NameUseOfficialPtr(),
                                        Family: utils.CreateStringPtr("Smith"),
                                        Given:  []string{"Jane"},
                                },
                        },
                        Gender:    utils.GenderPtr("female"),
                        BirthDate: utils.CreateStringPtr("1990-05-15"),
                        Telecom: []fhir.ContactPoint{
                                {
                                        System: utils.SystemPtr("email"),
                                        Value:  utils.CreateStringPtr("jane.smith@example.com"),
                                        Use:    utils.UsePtr("home"),
                                },
                        },
                        Address: []fhir.Address{
                                {
                                        Line:       []string{"456 Oak Ave"},
                                        City:       utils.CreateStringPtr("Gotham"),
                                        State:      utils.CreateStringPtr("CA"),
                                        PostalCode: utils.CreateStringPtr("67890"),
                                        Country:    utils.CreateStringPtr("USA"),
                                },
                        },
                },
                {
                        Active: utils.CreateBoolPtr(false),
                        Name: []fhir.HumanName{
                                {
                                        Use:    utils.NameUseOfficialPtr(),
                                        Family: utils.CreateStringPtr("Brown"),
                                        Given:  []string{"Charlie"},
                                },
                        },
                        Gender:    utils.GenderPtr("other"),
                        BirthDate: utils.CreateStringPtr("2000-12-31"),
                        Telecom: []fhir.ContactPoint{
                                {
                                        System: utils.SystemPtr("email"),
                                        Value:  utils.CreateStringPtr("charlie.brown@example.com"),
                                        Use:    utils.UsePtr("work"),
                                },
                        },
                        Address: []fhir.Address{
                                {
                                        Line:       []string{"789 Pine Rd"},
                                        City:       utils.CreateStringPtr("Star City"),
                                        State:      utils.CreateStringPtr("WA"),
                                        PostalCode: utils.CreateStringPtr("24680"),
                                        Country:    utils.CreateStringPtr("USA"),
                                },
                        },
                },
        }

        for _, dummy := range dummyPatients </span><span class="cov0" title="0">{
                // Check if patient exists by unique fields (family, given, birthdate, gender)
                var count int64
                db.Model(&amp;domain.Patient{}).
                        Where("family = ? AND given = ? AND gender = ? AND birth_date = ?",
                                *dummy.Name[0].Family,
                                func() string </span><span class="cov0" title="0">{
                                        if len(dummy.Name[0].Given) &gt; 0 </span><span class="cov0" title="0">{
                                                return dummy.Name[0].Given[0]
                                        }</span> else<span class="cov0" title="0"> {
                                                return ""
                                        }</span>
                                }(),
                                dummy.Gender,
                                *dummy.BirthDate,
                        ).Count(&amp;count)
                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                        _, err := patientService.CreatePatient(&amp;dummy)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to seed dummy patient: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Infof("Seeded dummy patient: %s %s", dummy.Name[0].Given[0], *dummy.Name[0].Family)
                        }</span>
                }
        }

        // --- End seed logic ---

        // Initialize handlers
        <span class="cov0" title="0">patientHandler := handlers.NewPatientHandler(patientService)
        externalPatientHandler := handlers.NewExternalPatientHandler(externalPatientService)

        // Set Gin mode
        gin.SetMode(cfg.Server.Mode)

        // Setup routes
        router := routes.SetupRoutes(patientHandler, externalPatientHandler) // Pass new handler to SetupRoutes

        // Swagger endpoint
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Configure server
        server := &amp;http.Server{
                Addr:         ":" + cfg.Server.Port,
                Handler:      router,
                ReadTimeout:  cfg.Server.ReadTimeout,
                WriteTimeout: cfg.Server.WriteTimeout,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Infof("Server starting on port %s", cfg.Server.Port)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to start server: %v", err)
                        os.Exit(1)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        // Gracefully shutdown the server with a timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Server forced to shutdown: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package database

import (
        "fmt"

        "go-fhir-demo/config"
        "go-fhir-demo/pkg/logger"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        gormLogger "gorm.io/gorm/logger"
)

var DB *gorm.DB

// Initialize sets up the database connection
func Initialize(cfg *config.DatabaseConfig) error <span class="cov0" title="0">{
        dsn := cfg.DSN()

        // Configure GORM logger
        var gormLogLevel gormLogger.LogLevel
        switch logger.GetLogger().Level </span>{
        case logger.GetLogger().Level:<span class="cov0" title="0">
                gormLogLevel = gormLogger.Info</span>
        default:<span class="cov0" title="0">
                gormLogLevel = gormLogger.Warn</span>
        }

        <span class="cov0" title="0">db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: gormLogger.Default.LogMode(gormLogLevel),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get database instance: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
        sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
        sqlDB.SetConnMaxLifetime(cfg.ConnMaxLifetime)

        // Test connection
        if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">DB = db
        logger.Info("Database connection established successfully")
        return nil</span>
}

// GetDB returns the database instance
func GetDB() *gorm.DB <span class="cov0" title="0">{
        return DB
}</span>

// Close closes the database connection
func Close() error <span class="cov0" title="0">{
        if DB != nil </span><span class="cov0" title="0">{
                sqlDB, err := DB.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return sqlDB.Close()</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package fhirclient

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/samply/golang-fhir-models/fhir-models/fhir"
)

// ClientInterface defines the contract for FHIR client
type ClientInterface interface {
        GetPatientByID(id string) (*fhir.Patient, error)
        SearchPatients(queryParams map[string]string) (*fhir.Bundle, error)
}

// Client is a client for interacting with a FHIR server.
type Client struct {
        BaseURL    string
        HTTPClient *http.Client
}

// NewClient creates a new FHIR client.
func NewClient(baseURL string) ClientInterface <span class="cov0" title="0">{
        return &amp;Client{
                BaseURL: baseURL,
                HTTPClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

// GetPatientByID fetches a Patient resource by its ID.
func (c *Client) GetPatientByID(id string) (*fhir.Patient, error) <span class="cov0" title="0">{
        reqURL := fmt.Sprintf("%s/Patient/%s", c.BaseURL, id)
        req, err := http.NewRequest("GET", reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/fhir+json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("fhir server returned non-OK status %d: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var patient fhir.Patient
        if err := json.NewDecoder(resp.Body).Decode(&amp;patient); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode patient response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;patient, nil</span>
}

// SearchPatients searches for Patient resources based on query parameters.
// It returns a FHIR Bundle containing the search results.
func (c *Client) SearchPatients(queryParams map[string]string) (*fhir.Bundle, error) <span class="cov0" title="0">{
        baseURL, err := url.Parse(fmt.Sprintf("%s/Patient", c.BaseURL))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse base URL: %w", err)
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        for k, v := range queryParams </span><span class="cov0" title="0">{
                params.Add(k, v)
        }</span>
        <span class="cov0" title="0">baseURL.RawQuery = params.Encode()

        req, err := http.NewRequest("GET", baseURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create search request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/fhir+json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute search request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("fhir server returned non-OK status for search %d: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var bundle fhir.Bundle
        if err := json.NewDecoder(resp.Body).Decode(&amp;bundle); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode bundle response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;bundle, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: client.go
//
// Generated by this command:
//
//        mockgen -source=client.go -destination=mocks\client_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        fhir "github.com/samply/golang-fhir-models/fhir-models/fhir"
        gomock "go.uber.org/mock/gomock"
)

// MockClientInterface is a mock of ClientInterface interface.
type MockClientInterface struct {
        ctrl     *gomock.Controller
        recorder *MockClientInterfaceMockRecorder
        isgomock struct{}
}

// MockClientInterfaceMockRecorder is the mock recorder for MockClientInterface.
type MockClientInterfaceMockRecorder struct {
        mock *MockClientInterface
}

// NewMockClientInterface creates a new mock instance.
func NewMockClientInterface(ctrl *gomock.Controller) *MockClientInterface <span class="cov0" title="0">{
        mock := &amp;MockClientInterface{ctrl: ctrl}
        mock.recorder = &amp;MockClientInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClientInterface) EXPECT() *MockClientInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetPatientByID mocks base method.
func (m *MockClientInterface) GetPatientByID(id string) (*fhir.Patient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPatientByID", id)
        ret0, _ := ret[0].(*fhir.Patient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPatientByID indicates an expected call of GetPatientByID.
func (mr *MockClientInterfaceMockRecorder) GetPatientByID(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPatientByID", reflect.TypeOf((*MockClientInterface)(nil).GetPatientByID), id)
}</span>

// SearchPatients mocks base method.
func (m *MockClientInterface) SearchPatients(queryParams map[string]string) (*fhir.Bundle, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchPatients", queryParams)
        ret0, _ := ret[0].(*fhir.Bundle)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchPatients indicates an expected call of SearchPatients.
func (mr *MockClientInterfaceMockRecorder) SearchPatients(queryParams any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchPatients", reflect.TypeOf((*MockClientInterface)(nil).SearchPatients), queryParams)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package logger

import (
        "io"
        "os"
        "path/filepath"

        "github.com/sirupsen/logrus"
)

var Logger *logrus.Logger

// Initialize sets up the logger with the given configuration
func Initialize(level, format, logFile string) error <span class="cov0" title="0">{
        Logger = logrus.New()

        // Set log level
        logLevel, err := logrus.ParseLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                logLevel = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">Logger.SetLevel(logLevel)

        // Set log format
        if format == "json" </span><span class="cov0" title="0">{
                Logger.SetFormatter(&amp;logrus.JSONFormatter{
                        TimestampFormat: "2006-01-02 15:04:05",
                })
        }</span> else<span class="cov0" title="0"> {
                Logger.SetFormatter(&amp;logrus.TextFormatter{
                        FullTimestamp:   true,
                        TimestampFormat: "2006-01-02 15:04:05",
                })
        }</span>

        // Set up log file output
        <span class="cov0" title="0">if logFile != "" </span><span class="cov0" title="0">{
                // Create log directory if it doesn't exist
                logDir := filepath.Dir(logFile)
                if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write to both file and stdout
                <span class="cov0" title="0">multiWriter := io.MultiWriter(os.Stdout, file)
                Logger.SetOutput(multiWriter)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetLogger returns the configured logger instance
func GetLogger() *logrus.Logger <span class="cov10" title="27">{
        if Logger == nil </span><span class="cov2" title="2">{
                Logger = logrus.New()
        }</span>
        <span class="cov10" title="27">return Logger</span>
}

// Info logs an info message
func Info(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Info(args...)
}</span>

// Infof logs a formatted info message
func Infof(format string, args ...interface{}) <span class="cov8" title="18">{
        GetLogger().Infof(format, args...)
}</span>

// Error logs an error message
func Error(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Error(args...)
}</span>

// Errorf logs a formatted error message
func Errorf(format string, args ...interface{}) <span class="cov6" title="7">{
        GetLogger().Errorf(format, args...)
}</span>

// Warn logs a warning message
func Warn(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Warn(args...)
}</span>

// Warnf logs a formatted warning message
func Warnf(format string, args ...interface{}) <span class="cov2" title="2">{
        GetLogger().Warnf(format, args...)
}</span>

// Debug logs a debug message
func Debug(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Debug(args...)
}</span>

// Debugf logs a formatted debug message
func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Debugf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package utils

import (
        "time"

        "github.com/samply/golang-fhir-models/fhir-models/fhir"
)

// PtrBool returns a pointer to the given bool value.
func PtrBool(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

// Helper function to create bool pointers
func CreateBoolPtr(b bool) *bool <span class="cov7" title="9">{
        return &amp;b
}</span>

// Helper function to create gender pointer using UnmarshalJSON
func GenderPtr(g string) *fhir.AdministrativeGender <span class="cov2" title="2">{
        var gender fhir.AdministrativeGender
        if err := gender.UnmarshalJSON([]byte(`"` + g + `"`)); err != nil </span><span class="cov0" title="0">{
                // If unknown or error, default to AdministrativeGenderUnknown
                gender = fhir.AdministrativeGenderUnknown
        }</span>
        <span class="cov2" title="2">return &amp;gender</span>
}

// Helper function to create system pointer
func SystemPtr(s string) *fhir.ContactPointSystem <span class="cov0" title="0">{
        var sys fhir.ContactPointSystem
        // Use UnmarshalJSON to leverage the built-in conversion logic
        if err := sys.UnmarshalJSON([]byte(`"` + s + `"`)); err != nil </span><span class="cov0" title="0">{
                // If unknown, default to ContactPointSystemOther
                sys = fhir.ContactPointSystemOther
        }</span>
        <span class="cov0" title="0">return &amp;sys</span>
}

// Helper function to create use pointer
func UsePtr(u string) *fhir.ContactPointUse <span class="cov0" title="0">{
        var use fhir.ContactPointUse
        if err := use.UnmarshalJSON([]byte(`"` + u + `"`)); err != nil </span><span class="cov0" title="0">{
                // If unknown, default to ContactPointUseHome or another sensible default
                use = fhir.ContactPointUseHome
        }</span>
        <span class="cov0" title="0">return &amp;use</span>
}

// Helper function to create string pointers
func CreateStringPtr(s string) *string <span class="cov10" title="25">{
        return &amp;s
}</span>

// Helper function to create NameUse pointer
func NameUseOfficialPtr() *fhir.NameUse <span class="cov0" title="0">{
        nameUse := fhir.NameUseOfficial
        return &amp;nameUse
}</span>

// Helper function to create time pointer
func CreateTimePtr(t string) *time.Time <span class="cov5" title="5">{
        var ft time.Time
        if err := ft.UnmarshalJSON([]byte(`"` + t + `"`)); err != nil </span><span class="cov5" title="5">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ft</span>
}

// Helper function to create date pointer
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
